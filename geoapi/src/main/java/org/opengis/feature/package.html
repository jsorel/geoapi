<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
  <HEAD>
    <TITLE>package org.opengis.feature</TITLE>
  </HEAD>
  <BODY>
  Gives a normalized interface to a data provider that can serve up collections
  of {@link org.opengis.feature.Feature} objects.
 
  <H3>Package Specification</H3>
  <P ALIGN="justify">This package is based on the following specifications:</P>
  <UL>
    <LI>Ref WFS spec for locking workflow</LI>
    <LI>Ref Catalog 2.0 spec for paging idea and QueryRequest paging idea</LI>
  </UL>

  <H3>WFS Long Transaction Support</H3>
  <P ALIGN="justify">The locking workflow described by {@link org.opengis.feature.FeatureCollection#lock()}
  methods and {@link org.opengis.feature.LockRequest}, and {@link org.opengis.feature.LockResponse},
  and indeed the {@link org.opengis.feature.Transaction} facilities employed by
  {@link org.opengis.feature.FeatureCollection} are informed by the requirements
  of the WFS specification.</P>
  
  <P ALIGN="justify">The WFS specification provides an attractive middle ground between full
  versioned Features, and light-weight in-process or file lock based approaches. Locks
  are maintained for a requested duration. A successful lock operation results
  in an authorization token that may be used at a later time. A transaction
  may be assigned a token allowing it to work on previously locked features.
  WFS allows a lock to be taken out across multiple {@code FeatureCollection}s in a single
  request. We have extended this idea to support {@link org.opengis.feature.FeatureCollection}
  from different {@link org.opengis.feature.FeatureStore}s - although we confess that the
  authorization tokens are still on a per {@code FeatureStore} basis.</p>

  <P ALIGN="justify">Code example:
  <BLOCKQUOTE><PRE>
  // The FilterFactory.bnf( "" ) method is unfortuantly mythical
  //
  FeatureStore featureStore = FeatureStoreFactory.create( new URI("myfile.gml") );
  GenericName roads = featureStore.getTypeNames().iterator().next();
  
  FeatureCollection kaslo = featureStore.getFeatures( roads, FilterFactory.bnf( "CITY='kaslo'" );
  LockRequest lockRequest = new LockRequest( 45678 );
  Transaction t = new Transaction();
  
  kaslo.setTransaction( t );
  kaslo.setLock( lockRequest );
  kaslo.lock(); // returns LockResponse.PENDING
  LockResponse lockResults = t.commit(); // kaslo roads are now locked
  
  String token = lockResults.getToken(); // token now contains a data store specific string (like WDRHENDHA123123ADEF )
                                         // This is a pure momento with no meaning to client code and no documented
                                         // internal strucutre. May not even be human readable.
      
  kaslo.deleteAll( kaslo.subCollection( FilterFactory.bnf( "CITY='kaslo' AND NAME='A street'" ) );
  try {
     t.commit(); // commit does not even return as we have a lock conflict ...
  } catch (IOException locked){
     // A stree is safe - we did not use authorization
     System.out.println("expected locking message:"+locked); 
  }
  
  t.useAuthorization( token );
  kaslo.deleteAll( kaslo.subCollection( FilterFactory.bnf( "CITY='kaslo' AND NAME='A street'" ) );
  lockResults = t.commit(); // lockResults now equals LockResults.NONE as this commit had no lock methods called
  </PRE></BLOCKQUOTE>

  <P ALIGN="justify">At the end of the above example, kaslo A street has been deleted and the remaining streets
  in kaslo are unlocked since the token has been used.</p>
  
  <H3>Related Documentation </H3>
  <UL>
   <LI>{@link org.opengis.metadata} - ISO 19115 (TC211) Metadata specification</LI>
   <LI>{@link org.opengis.filter} - defines a query language similar in scope to QueryDefinition</LI>   
  </UL>

  </BODY>
</HTML>
