<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
<HEAD>
<TITLE>package org.opengis.feature.type</TITLE>
</HEAD>
<BODY>
Captures the generic feature model from ISO 19109 with allowances for
usability.
<p>This feature model has been produced after review of the ISO 19109
specification, and a review of several java implementations. The goal of
this package is to capture the type information for the "general feature
model".</p>
<p>The following goals have been set:
<ul>
	<li>support reflection on application schema
	<li>encourage the use of access via a Query lanaguage (provided by the
	Filter specification)
	<li>capture enough information to permit the seamless handling models
	taken from XML specifications, in particular the use of sequence,
	choice and XPath access have proven a challenge.
	<li>permit the definition of a SimpleFeatureType similar in spirit to
	the previous GeoAPI feature model in which accessor methods may be used
	directly and are based around simple Strings.
	<li>use naming consistent with the ISO 19109 specification
	<li>be consistent with common java usage conventions
</ul>

<h2>Type System</h2>
<p>The following ideas are central to the functioning of this package as
a feature model:
<ul>
	<li>Schema holds AttributeTypes by TypeName, these names are also
	available in a Namespace
	<li>AttributeType is the base "Type" in the system, it is bound against
	a java Class and may be reused.
	<li>AttributeType may indicate available operations using
	"OperationDescriptors", these descriptors have an OperationType
	describing their required parameters as list of AttributeTypes
	<li>AttributeType contains set of Filters that are used to "constrain"
	the permissible value
	<li>AttributeType is allowed to be an extention of a super type. This
	presents one known issue: the bound java classes may not be compatible
	even if in terms of modeling a subset is properly represented (An
	example is Integer representing a subset of BigInteger).
	<li>ComplexType contains additional PropertyDescriptors describing
	attributes and associations with their multiplicity.
	<li>FeatureType explicitly represents a spatial type, with additional
	information such as CRS and default geometry
	<li>FeatureCollectionType indicates its associated member FeatureTypes
	with an AssociationDescriptor that is bound to a FeatureType.
</ul>
</p>
<center><img src="doc-files/fm.png"></center>
<p>There are some open questions:
<ul>
	<li>Should we make a structured property descriptor that holds is
	extended for attribute and association? This information should include
	the cardinality information, and would allow for an useful list to be
	returned for ComplexType getStructuredProperties(). This was in Bryce's
	proposal, however it has not yet been needed for implementation.
	<li>Can an association type work against an non identified
	AttributeType?<br>
	Since our current use is limited to FeatureCollection members we will
	not be able to answer at this time. If this proves true we will need to
	explicitly make an interface for IdentifiedType, right now it was only
	viewed as of interest to those doing persistence to XML or a database.
	
</ul>

<h2>Differences from ISO 19103 with respect to Naming</h2>
<p>We have explicilty made the following break with ISO 19103:
<ul>
	<li>Name - we have adopted a simple definition of Name based on QName.
	The ISO implementation combined the responsibilities of naming with the
	implementation of a chained linked list of names. The result was heavy
	weight, and strange and has not proved intuitive.
	<li>Namespace - implemented as Set<Name>, this is also a taged with its
	own Namespace. The ISO implementation combined the responsibilities of
	lookup with those of maintaining a namespace scope for a provided name
	(ie bidirectional link between Namespace and Name). The required
	backpointer prevented Name from being lightweight and has been removed.</li>
</ul>
As indicated above we have removed the "back pointers" required to
navigate from Name to its "context", instead we have provided a URI
which should be used with your lookup system of choice. This choice may
in fact be Namespace (and is when working with TypeNames in a Schema),
however the actual implementation should be provided by the hosting
language in many cases.
<center><img src="doc-files/name.png"></center>
<p>There is room for improvement - If possible we would prefer to use
the javax.naming.Name API and keep even less API around for these
concerns. As it is we offer this as a recommendation.
<p>For more details of this change please review the Name and Namespace
interfaces which covers this in more detail.
<h2>Differences from ISO 19109 with respect to General Feature Model</h2>
<p>We have explicitly made the following break with ISO 19109:
<ul>
	<li>TypeName - we have separated out the concerns of TypeDefinition
	from TypeName, in ISO 19109 these were combined and caused great
	confusion when implementing.
	<li>AttributeName - also seperated from AttributeType in a similar
	manner.
</ul>
Numerous other changes have been made to leverage Java collection API
where appropriate. These represent a direct mapping onto the language
constructs and may or may not prove significant to those arriving from an
ISO 19109 background.
</p>
<h2>Relationship to ISO 19109 Primer</h2>
<p>This work is greatly informed from a proposal included in the ISO
19109 primer - written by Bryce. In particular the requirement for
operations, associations and detailed review of ISO19109, and EMF was a
great asset. This primer also served as the only public documentation of
the ISO 19109 material available for open development.
<p>Differences from Bryce's proposal:
<ul>
	<li>Name, TypeName and Namespace as above
	<li>Schema - we once again do not combine implementation with
	identification (the proposal for Package extended ScopedName). We have
	implemened a Schema class as a Map<TypeName ,AttributeType> this works
	out nicely as the keySet ends up being the Namespace for the Schema.
	<li>Factory and Type separation, we have explicitly not extended our
	type Schema class in order to make a FeatureFactory. A requirement of
	the type system is to allow for application supplied FeatureType
	creation, this is a seperate concern then modeling and grouping feature
	types.
</ul>
The definition of Record and Name were unresolved at the time of this
work and has not been integrated. In particular the definition of Name
was taken as "too complicated".
</p>
<p>We also disagreed with one of the goals of the proposal: <i>convention
that the creation of objects inside an application schema is the
responsibility of the schema author</i>. This goal is in conflict with
our need to allow applications to create instances of their own
devising. This need is particulary apparent when an application needs to
ensure the use of a specific base class (for example to work with a
persistence system Jaxtor, or modeling system like EMF).</p>
</BODY>

</HTML>
