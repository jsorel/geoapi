<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
<HEAD>
<TITLE>package org.opengis.feature.xml</TITLE>
</HEAD>
<BODY>
Helper classes to model XML content as a {@linkplain
org.opengis.feature.Feature}, these add no additional modeling power -
they simply document the best practice.

<p>The XML model is similar, but more permissive, then that employed by
the feature model. In particular two ideas give rise to trouble:
ordering constraints (all,sequence,choice) and grouping (repeat series
of attributes).</p>
</p>
<ul>
	<li>All - modeled as a {@linkplain
	org.opengis.feature.ComplexAttribute}, contains a colleciton of
	attributes
	<li>Sequence - modeled as a {@linkplain
	org.opengis.feature.xml.Sequence}, specifies that attributes are
	returned in a List of attribtues
	<li>Choice - models as a {@linkplain org.opengis.feature.xml.Choice},
	specifies attributes are returned in a list of length 1
</ul>
<p>To model the concept of anonymous groups of attribtues you will need
to explicity model this behavior with the above constructs (aka strongly
type them), to preserve the inline behavior for XPath you can make use
of {@linkplain org.opengis.feature.type.ComplexType.isInline}</p>

<h2>Namespace vs URI</h2>
<p>This is a real knock down brawl between the XML Schema happy and the
ISO modelers, and where most of the remaining friction in this api
occurs. This is complicated by the fact that a lot of the same words are
used in both places:</p>
<ul>
	<li>xsd:schema - maps to a Schema, with lookup by Namespace,
	targetNamespace used for Name of Schema (and Namespace)
	<li>xsd:element - maps to an AttributeType, with TypeName based on
	targetNamespace + xsd:element name, this TypeName and AttributeType are
	placed in the Schema for safe keeping and lookup.
	<li>xsd:complexType - maps to a ComplexType, with TypeName based on
	targetNamespace + xsd:element, this TypeName and ComplexType are placed
	into the Schema
	<ul>
		<li>xsd:element (local) - will be defined with a TypeName based on
		complexType + element name, this value is not placed into any Schema,
		a Namespace could be associated with the Type if you want?
	</ul>
</ul>
<p>So lets work out what maps to what - using the following example:
<pre><code>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns:tns="http://example.org/employee/"
  targetNamespace="http://example.org/employee/"&gt;
  &lt;xsd:complexType name="EmployeeType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="name"/ type="xsd:string"/&gt;
      &lt;xsd:element name="hiredate" type="xsd:date"/&gt;      
      &lt;xsd:element name="salary"/ type="xsd:double"&gt;        
    &lt;/xsd:sequence&gt; 
  &lt;/xsd:complexType&gt; 
  &lt;xsd:element name="employee" type="tns:EmployeeType"/&gt;
&lt;/xsd:schema&gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre> And now lets see what is created:
<ul>
	<li>Schema
	<ul>
		<li>Name: http://example.org/employee/<br>
		used for Schema and Namespace, this Name is global and is not itself
		in a namespace</li>
		<li>Namespace: this is just the keySet for the Schema</li>
	</ul>
	</li>
	<li>ComplexType - created in Schema
	<ul>
		<li>Name: http://example.org/employee/EmployeeType with Namespace
		above</li>
		<li>AttributeDescriptors: Named "name", "hiredate" and "salaray"<br>
		These names are "global" and are not in a namespace, the
		AttributeDescriptor have AttributeTypes defined by the simple types,
		these have already been setup and bound to the Java classes String, Date and
		Double. The simple types are available for lookup in their own Schema
		object.</li>
	</ul>
	</li>
</ul>
The entry in the schema for "employee" is not used by the type system, it is only
of interest to a parser reading an actual document.
</p>
<p>
Based on the above example we create the following code:
<pre><code>
Schema schema;                                  // already set up

Namespace namespace = schema.keySet(); 
System.out.println( namespace.getURI() );       // prints http://example.org/employee/
Name name = namespace.lookup( "EmployeeType" ); // look up using a String
System.out.println( name == namespace.iterator().next() ); // true!
System.out.println( name );                     // prints http://example.org/employee/EmployeeType

AttributeType type = schema.get( name );        // retrive actual type
ComplexType employeeType = (ComplexType) type;
AttributeDescriptor a = getAttributes().iterator().next();

AttributeName aName = a.getName();
System.out.println( aName );                    // global name like "salary" that is not in a namespace

AttributeType aType = a.getType();
System.out.println( aType.getName() );          // name like "http://www.w3.org/2001/XMLSchema/date"
</code></pre>
Hope this helps!
</p>
</BODY>

</HTML>
